#include <iostream>
#include <utility>
#include <random> // Only needed for dev
#include <queue>
#include <unordered_map>
#include <string>
#include <cmath>
#include <iomanip>
#include "MontanaDeck.h"
#include "State.h"

const int MAX_RESHUFFLES{10};

template <typename T>
void display(std::priority_queue<T> pq)
{
  std::cout << "[\n";
  while (!pq.empty())
  {
    T elem = pq.top();
    pq.pop();
    std::cout << elem << " ";
  }
  std::cout << "]" << std::endl;
}

// 15 -> 33673
// 10 -> 123826
// 9 -> 43531
// 8 -> 252462

// const int MAX_ATTEMPTS{100000};
// const double DRAIN_PERCENTAGE{0.10};
// const int PQ_TRIM_TRIGGER_AMOUNT{5};
// const int PQ_TRIM_THRESHOLD{5};
/**
 * @todo
 * - Add score threshold limit
 */
// const double PQ_LIMIT{5};

// int attempts{0};
// int highest{-100};

// struct compare
// {
//   bool operator()(Move &a, Move &b) // overloading both operators
//   {
//     std::cout << "COMPARE via struct" << std::endl;
//     return a.get_score() < b.get_score(); // if you want increasing order;(i.e increasing for minPQ)
//   }
// };

/**
 * Change to State
 * initial
 * current
 * history
 * move
 * score
 */

// class Move
// {
//   friend std::ostream &operator<<(std::ostream &os, const Move &rhs);
//   // friend bool operator<(const Move &x, const Move &rhs);

//   std::pair<int, int> move{0, 0};
//   MontanaDeck deck{}; // State of deck prior to move
//   int score{0};

// public:
//   // Move() = default;
//   Move(std::pair<int, int> move, MontanaDeck deck, int score)
//       : move{move}, deck{deck}, score{score} {}

//   // std::pair<int, int> get_move() const;
//   // MontanaDeck get_deck() const;
//   // int get_score() const;
//   // bool operator<(const Move &rhs) const;
//   // bool operator>(const Move &rhs) const;
//   // bool operator==(const Move &rhs) const;
//   // void display() const;

//   bool operator<(const Move &rhs) const
//   {
//     // std::cout << "COMPARING < m1" << std::endl;
//     // std::cout << "Comparing " << score << " to " << rhs.score << std::endl;
//     return this->score < rhs.score;
//   }

//   bool operator>(const Move &rhs) const
//   {
//     // std::cout << "COMPARING >" << std::endl;
//     // std::cout << "Comparing " << score << " to " << rhs.score << std::endl;
//     return this->score > rhs.score;
//   }

//   std::pair<int, int> get_move() const
//   {
//     return move;
//   }

//   MontanaDeck get_deck() const
//   {
//     return deck;
//   }

//   int get_score() const
//   {
//     return score;
//   }

//   bool operator==(const Move &rhs) const
//   {
//     std::stringstream ss_this{};
//     std::stringstream ss_rhs{};

//     // std::cout << "base" << std::endl;
//     // std::cout << this->get_move().first << std::endl;
//     // std::cout << "test" << std::endl;
//     // std::cout << rhs.get_move().first << std::endl;

//     ss_this << this->get_move().first << "*" << this->get_move().second;
//     ss_rhs << rhs.get_move().first << "*" << rhs.get_move().second;

//     // std::cout << "base-" << std::endl;
//     // std::cout << *this << std::endl;

//     // std::cout << "--- get this hash ---" << std::endl;
//     // std::cout << "--- " << this->deck << " ---" << std::endl;
//     std::string deck_this = this->get_deck().get_hash();
//     // std::cout << "--- got this hash ---" << std::endl;
//     // std::cout << "test-" << std::endl;
//     // std::cout << rhs << std::endl;
//     // std::cout << "--- get rhs hash ---" << std::endl;
//     std::string deck_rhs = rhs.get_deck().get_hash();
//     // std::cout << "--- got rhs hash ---" << std::endl;

//     return (ss_this.str() == ss_rhs.str() &&
//             deck_this == deck_rhs);
//   }

//   // void display() const
//   // {
//   //   std::cout << "Move: (" << move.first << ", " << move.second << ")"
//   //             << " " << score
//   //             << " [" << deck << "]"
//   //             << std::endl;
//   // }
// };

// class Move2
// {
//   friend std::ostream &operator<<(std::ostream &os, const Move &rhs);
//   // friend bool operator<(const Move &x, const Move &rhs);

//   std::pair<int, int> move{0, 0};
//   // MontanaDeck deck{}; // State of deck prior to move
//   int score{0};

// public:
//   // Move() = default;
//   // Move(std::pair<int, int> move, MontanaDeck deck, int score)
//   //     : move{move}, deck{deck}, score{score} {}
//   Move2(std::pair<int, int> move, int score)
//       : move{move}, score{score} {}

//   // std::pair<int, int> get_move() const;
//   // MontanaDeck get_deck() const;
//   // int get_score() const;
//   // bool operator<(const Move &rhs) const;
//   // bool operator>(const Move &rhs) const;
//   // bool operator==(const Move &rhs) const;
//   // void display() const;

//   bool operator<(const Move2 &rhs) const
//   {
//     std::cout << "COMPARING < m2" << std::endl;
//     // std::cout << "Comparing " << score << " to " << rhs.score << std::endl;
//     return this->score < rhs.score;
//   }

//   std::pair<int, int> get_move() const
//   {
//     return move;
//   }

//   int get_score() const
//   {
//     return score;
//   }
// };

// std::ostream &operator<<(std::ostream &os, const Move &rhs)
// {
//   os << "Move: (" << rhs.get_move().first << ", " << rhs.get_move().second << ")"
//      << " " << rhs.get_score()
//      << "\n"
//      << rhs.get_deck();
//   return os;
// }

/**
 * Sadly this doesn't work, but I'm not sure why.
 */
// template <typename T>
// std::ostream &operator<<(std::ostream &os, const std::vector<T> &v)
// {
//   os << "[";
//   for (const auto &element : v)
//   {
//     os << element << " ";
//   }
//   os << "]";
//   return os;
// }

int calculate_deck_score(MontanaDeck deck)
{
  int score{0};
  // For decks with a lot of cards in sequence, give a very high value.
  /**
   * @todo
   * - Would be cool to do on a sliding scale--the greater the sequence,
   *   the proportionally higher the score.
   * - Would also be good to do a "sliding window" and determine how many
   *   cards are in sequence, regardless of whether or not they start at 2.
   */
  score += deck.calculate_total_in_sequence() * 50;

  // Rows that already have a 2 in the first gap get a high score.
  std::vector<int> starting_indexes = MontanaDeck::get_row_starting_indices();
  for (auto index : starting_indexes)
  {
    Card current = deck.get_deck()[index];
    if (current.is_deuce())
    {
      score += 100;
    }
    if (current.is_ace())
    {
      score += 80;
    }
  }

  return score;
}

int calculate_score(MontanaDeck deck, std::pair<int, int> move)
{
  int score{0};
  score += calculate_deck_score(deck);

  Card current = deck.get_deck()[move.second];
  Card gap = deck.get_deck()[move.first];
  Card previous = deck.get_previous_card(move.second);
  Card next = deck.get_next_card(move.second);

  // std::cout << "Current: " << current.suit_key << current.card_key << std::endl;
  // std::cout << "Next: " << next.suit_key << next.card_key << std::endl;

  // Moving a 2 to the leftmost column gets a very high value.
  if (MontanaDeck::is_first_column(move.first) && current.is_deuce())
  {
    score += 200;
  }

  // For gaps that immediately follow a sequence break, give a very high score.
  std::vector<int> gaps = deck.find_sequence_break_indices();
  for (auto gap : gaps)
  {
    if (gap == move.first)
    {
      score += 75;
      break;
    }
  }

  // If moving a king would have it in front of a gap, give it a very low score.
  if (current.is_king() && next.is_ace())
  {
    score -= 50;
  }
  // If the move involves a space in the last position for a row and not
  // preceded by a king, give a very low value
  if (MontanaDeck::is_last_column(move.second) && !previous.is_king())
  {
    score -= 50;
  }
  // Moving a 2 away from the leftmost column gets a very low value.
  if (MontanaDeck::is_first_column(move.second) && current.is_deuce())
  {
    score -= 90;
  }

  return score;
  /**
   * - determine the state of the move
   *   - moving a card to close to its proper sequence gets proportionally higher value
   *   - moving a card to a space away from its proper sequence gets a proportionally lower value
   *   - moving a card to its proper suit gets a somewhat high value
   * */
  // std::random_device rd;  // obtain a random number from hardware
  // std::mt19937 gen(rd()); // seed the generator
  // // std::mt19937 gen();
  // std::uniform_int_distribution<> distr(-10, 100); // define the range

  // return distr(gen);
}

// std::priority_queue<State> trim_priority_queue(std::priority_queue<State> source, int limit)
// {
//   std::priority_queue<State> result{};
//   int count{0};
//   while (!source.empty())
//   {
//     if (count >= limit)
//     {
//       break;
//     }
//     result.push(source.top());
//     source.pop();
//     count++;
//   }
//   return result;
// }

// bool does_state_exist_in_queue(std::priority_queue<Move, std::vector<Move>, compare> pq, Move &move)
bool does_state_exist_in_queue(std::priority_queue<State> pq, State &state)
{
  while (!pq.empty())
  {
    auto test = pq.top();
    pq.pop();
    if (test == state)
    {
      // std::cout << "EQUALS MOVE" << test << " " << move << std::endl;
      // std::cout << "---!after equals (true)!---" << std::endl;
      return true;
    }
  }
  // std::cout << "---!after equals (false)!---" << std::endl;
  return false;
}

std::vector<State> determine_moves(MontanaDeck &deck, std::priority_queue<State> &pq)
{
  std::vector<std::pair<int, int>> possible_moves = deck.find_moves();
  std::vector<State> move_states{};

  // std::cout << possible_moves.size() << "?" << std::endl;
  for (auto move : possible_moves)
  {
    State state{move, deck, calculate_score(deck, move)};
    if (!does_state_exist_in_queue(pq, state))
    {
      move_states.push_back(state);
    }
  }
  return move_states;
}

void add_moves(std::priority_queue<State> &pq, std::vector<State> &move_states)
{
  for (auto move_state : move_states)
  {
    pq.push(move_state);
  }
}

State get_move(std::priority_queue<State> &pq)
{
  auto move = pq.top();
  pq.pop();
  return move;
}

MontanaDeck make_move(State move)
{
  auto move_deck = move.get_deck();
  move_deck.move(move.get_move().first, move.get_move().second);
  return move_deck;
}

bool check_key(const std::unordered_map<std::string, bool> m, std::string key)
{
  return m.find(key) != m.end();
}

bool can_reshuffle(State move_state)
{
  return move_state.get_reshuffles() < MAX_RESHUFFLES;
}
// {
//   if (deck.is_goal())
//   {
//     std::cout << "*** SOLUTION!!! ***" << std::endl;
//     return {true, deck};
//   }

//   std::vector<std::pair<int, int>> moves = deck.find_moves();
//   if (moves.size() == 0 && pq.empty())
//   {
//     if (moves.size() == 0)
//     {
//       std::cout << "No available moves" << std::endl;
//     }
//     if (pq.empty())
//     {
//       std::cout << "Moves queue is empty" << std::endl;
//     }

//     if (!deck.is_reshufflable())
//     {
//       return {false, deck};
//     }

//     deck.reshuffle();
//     return solve(deck, pq);
//   }

//   for (auto move : moves)
//   {
//     Move m{move, deck, calculate_score(deck, move)};
//     Card previous = deck.get_deck()[move.first];
//     Card current = deck.get_deck()[move.second];
//     // std::cout << previous.suit_key << previous.card_key << std::endl;
//     // std::cout << current.suit_key << current.card_key << std::endl;
//     // std::cout << "--- " << moves.size() << " ---" << std::endl;
//     if (!does_state_exist_in_queue(pq, m))
//     {
//       // std::cout << "---!push!---" << std::endl;
//       // std::cout << m << std::endl;
//       pq.push(m);
//     }
//   }
//   // std::cout << "---?" << pq.size() << "?---" << std::endl;

//   // if (attempts > 3)
//   // {
//   //   display(pq);
//   //   exit(0);
//   // }

//   /**
//    * @todo
//    * Remove when solved.
//    */
//   attempts++;
//   // std::cout << "Attempts " << attempts << std::endl;
//   if (attempts >= MAX_ATTEMPTS)
//   {
//     std::cout << "Exceeded number of attempts" << std::endl;
//     return {false, deck};
//   }
//   /***/

//   /**
//    * @todo
//    * Always drain a percentage of the queue.
//    * - Drain 10% of the queue
//    */
//   // std::cout << pq.size() << std::endl;
//   // int drain = std::ceil(pq.size() * DRAIN_PERCENTAGE);
//   // for (int i = 0; i < drain; i++)
//   // {
//   //   auto move = pq.top();
//   //   if (move.get_score() > highest)
//   //   {
//   //     highest = move.get_score();
//   //     std::cout << ": " << highest << std::endl;
//   //   }
//   //   pq.pop();
//   //   // std::cout << pq.size() << std::endl;
//   //   // std::cout << "Move: " << move.get_score() << std::endl;
//   //   auto move_deck = move.get_deck();
//   //   move_deck.move(move.get_move().first, move.get_move().second);

//   //   return solve(move_deck, pq);
//   // }

//   if (pq.size() > PQ_LIMIT)
//   {
//     pq = trim_priority_queue(pq, PQ_LIMIT);
//     // std::cout << "-- trimming --" << std::endl;
//   }

//   auto move = pq.top();

//   std::cout << "=== " << pq.size() << " ===" << std::endl;

//   if (move.get_score() > highest)
//   {
//     highest = move.get_score();
//     std::cout << ": " << highest << std::endl;
//   }
//   pq.pop();
//   // std::cout << pq.size() << std::endl;
//   // std::cout << "Move: " << move.get_score() << std::endl;
//   auto move_deck = move.get_deck();
//   move_deck.move(move.get_move().first, move.get_move().second);

//   return solve(move_deck, pq);
// }

// template <typename T, S, R>
// void display(std::priority_queue<Move, std::vector<Move>, compare> &pq)
// {
//   std::cout << "[ ";
//   while (!pq.empty())
//   {
//     Move elem = pq.top();
//     pq.pop();
//     std::cout << elem << " ";
//   }
//   std::cout << "]" << std::endl;
// }

// template <typename T>
// std::ostream &operator<<(std::ostream &os, const std::vector<T> &v)
// {
//   os << "[";
//   for (const auto &element : v)
//   {
//     os << element << " ";
//   }
//   os << "]";
//   return os;
// }

/**
 * @todo
 * Restructure
 *  - Remove recursion
 *    - get moves
 *    - add to queue
 *    - iterate through queue
 *
 * - Create hashmap of decks
 *   - moves for each(?)
 *   - attempted
 *   - if in queue,
 *     - don't determine moves
 *   - if attempted,
 *     - don't add moves to queue
 *
 *  - Get all decks from hashmap that have not been attempted.
 *  - Determine their moves.
 *  - Add moves to queue
 *  - Mark them as attempted.
 *
 *  - Add the first deck to the hashmap
 *  - Get its moves
 *  - Add the moves to the queue
 * - Do while the queue is not empty
 *
 * - Deck
 * - Number of reshuffles
 */

int main()
{
  MontanaDeck initial_deck{};
  MontanaDeck updated_deck{};
  std::pair<bool, MontanaDeck> result{false, initial_deck};
  std::priority_queue<State> pq{};
  std::unordered_map<std::string, bool> hm{};
  std::vector<State> move_states{};
  State move_state{};
  bool is_solved{false};

  // int move_count{0};

  initial_deck.initialize();
  initial_deck.shuffle();
  /**
   * @todo
   * Duplicated here and in while. Create a function.
   */
  hm[initial_deck.get_hash()] = true;
  move_states = determine_moves(initial_deck, pq);
  add_moves(pq, move_states);
  /** */

  initial_deck.display();
  // std::cout << move_count << "-------------------" << std::endl;
  // display(pq);
  // std::cout << move_states.size() << "===================" << std::endl;

  int iterations{0};
  while (pq.size() != 0)
  {
    iterations++;
    move_state = get_move(pq);
    updated_deck = make_move(move_state);

    if (updated_deck.is_goal())
    {
      is_solved = true;
      break;
    }

    if (check_key(hm, updated_deck.get_hash()))
    {
      // std::cout << "Already attempted" << std::endl;
      continue; // We've already attempted this deck.
    }

    move_state.set_deck_score(calculate_deck_score(updated_deck));

    initial_deck.display();
    std::cout << "=== " << std::setw(6) << pq.size() << " ===" << std::setw(12) << iterations << " ===" << std::endl;
    updated_deck.display();
    // std::cout << "------" << std::endl;

    hm[updated_deck.get_hash()] = true;
    move_states = determine_moves(updated_deck, pq);
    if (move_states.size() == 0)
    {
      if (can_reshuffle(move_state))
      {
        State s{};
        s.set_reshuffles(move_state.get_reshuffles() + 1);
        updated_deck.reshuffle();
        s.set_deck(updated_deck);
        move_states.push_back(s);
        std::cout << "RESHUFFLING" << std::endl;
      }
      else
      {
        std::cout << "No available reshuffles" << std::endl;
      }
    }

    add_moves(pq, move_states);

    // }

    // Check if the updated deck has been attempted.
    // If not, get its moves
    //  if moves count is 0,
    //   check reshuffle count
    //   if reshuffle count is less than amount allowed,
    //    reshuffle
    //    increment shuffle count
    //    get moves
    //    add to the priority queue
    //  add to the priority queue

    // m[deck.get_hash()] = true;
    // add_moves(deck, pq);

    // if (moves.size() == 0)
    // {
    //   std::cout << "No available moves" << std::endl;
    // }
  }

  // result = solve(deck, pq);
  // if (result.first)
  // {
  //   break;
  // }

  // std::cout << "Attempts: \n"
  //           << attempts
  //           << std::endl;
  // attempts = 0;

  // std::cout << "pq size " << pq.size() << std::endl;
  // std::cout << "-------------------" << std::endl;
  // std::cout << pq.top() << std::endl;
  // std::cout << "-------------------" << std::endl;

  // deck.display();
  // } while (!result.first);

  // deck.display();
  std::cout << "Solved: " << std::boolalpha << is_solved << "\n"
            << updated_deck << "\n"
            // << "Attempts: " << attempts << "\n"
            << "Items remaining in queue: " << pq.size() << "\n"
            << std::endl;

  // std::cout << "-------------------" << std::endl;

  return 0;
}
